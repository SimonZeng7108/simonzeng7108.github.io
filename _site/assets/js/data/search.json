[
  
  {
    "title": "Git it right",
    "url": "/posts/gititright/",
    "categories": "Computer Science",
    "tags": "Git, Github, Version Control, Terminal",
    "date": "2023-02-21 21:00:00 +0100",
    





    
    "snippet": "Git was developed by Linus Torvalds during the fathering of Linux in 2005. It is a distributed version control system, meaning you can tracked the changes of your files and folders in a project and...",
    "content": "Git was developed by Linus Torvalds during the fathering of Linux in 2005. It is a distributed version control system, meaning you can tracked the changes of your files and folders in a project and easily switch between different versions. it is now a standard tool for industrial project development. Collaborators can work on the same project at the same time with different versions. As a product from the biggest advocate of the Open-source-software movement, Git is made all free and open source. It is a great tool to track personal projects and tidy up the drive(no more “final_version”, “final_version2”, “final_final_version”…). Github/Gitlab are the most popular platforms for storing Git repositories. Technically git can track any type of files, small block of codes/texts to large images or videos. As long as there is change in the file directory, git can track it. However, it is not recommended to track large files with git, since all historical changes are stored in the .git folder, even if an images is deleted after commits, the git storage size will still be the same, which is not ideal to upload to Github/Gitlab or other cloud hosting services. In this post, I will introduce the basic usage of git and how to communicate with cloud hosting services like Github/Gitlab. This post can also be used as look up table or cookbook for future use.   “Git” in Turkish language means “go; move”To-do in this post:  Git installation  Git commands  Git configurations  Git with Github/Gitlab  Git with VScode  Git illustration diagramGit installation  Windows:  Install Git here, just follow the default installation settings.   Linux:  It only makes sense that git is already installed in Linux. If not,     sudo apt install git-all      Once installed, you can check the version of git by typing in the terminal:git --versionTrack the changesGo to a directory you want to track, either empty or with files/folders in it.Initialize a git repository:git initOnce you have done some changes in the directory, any untracked changes will appear in red. Check any changes in the directory:git statusThe changes can be added to the staging area, which is a temporary area where you can review the changes before committing. It’s like a shopping cart, you can add/remove items before you check out. Add the changes to the staging area:git add &lt;file_name&gt; # add a specific filegit add . # add all files, or git add -A/-allgit add -u # update the changes to in the files that are already trackedIf you changed your mind and don’t want to track the changes. Remove the file stage status from the staging area:git restore --staged &lt;file_name&gt; # remove a specific file stage statusgit rm --cached &lt;file_name&gt; # remove a specific file stage status, most cases the same as abovegit rm --cached -r . # remove all files stage statusIf you changed your mind about the modifications to some files Remove the file changes:git restore &lt;file_name&gt; # remove the file changesRemove files:rm &lt;file_name&gt; # remove the file it is not yet trackedgit rm &lt;file_name&gt; # remove the file and add to staging areaOnce you are happy with the changes, the changes will appear in green in the staging area. You can commit the changes to the local repository. e.g. Checkout at the cashier with the items in the shopping cartCommit the changes to the local repository:git commit -m \"commit message\" # commit the changes with a messagegit commit -am \"commit message\" # add and commit the changes with a messageCheck all the commit history:git log # check the commit historygit log --oneline # check the commit history in one linegit log --stat -m # check the commit history with pathes.press q on keyboard to exit the log.If you regret the commit, and want to undo the commit. You have to specify which commit you want reset back to, the current commit is named HEAD, its previous commit is HEAD^ or HEAD~1, the second previous commit is HEAD~2 and etc. Another way to specify commit is to use &lt;commit id&gt;, you can check the commit id by using git log and the id is in orange. You can copy any number of digits you want to call a commit id, but it has to be at least 4 digits.Undo commit:git update-ref -d HEAD # Delete the initial commit after the first commitgit reset --soft HEAD~1 # Undo the last commit keep the changes in staging areagit reset --hard HEAD~1 # Undo the last commit and discard the changesgit revert &lt;commit id&gt; # Create a new commit explicitly to undo that commitgit commit --amend # Modify the last commit messageCompare file or commit changesgit diff # compare the files changes before staginggit diff --staged # compare the files changes after staging before commit, equivalent to --cachedgit diff &lt;commit id&gt; &lt;commit id&gt; # compare the changes between two commitsThere are also ways to temporarily save the changes without committing, which is called stash. Stash the changes:git stash # stash the changesgit stash save \"stash message\" # stash the changes with a messagegit stash list # check the stash listgit stash apply # apply the last stashgit stash drop # remove the last stash from the stash listgit stash pop # apply the last stash and remove it from the stash listgit stash clear # remove all the stashes from the stash listgit stash show # show the last stash changesFor some large files, you might want to ignore the changes to the file. It may cause unreasonably large git storage size. Ignore files are not preferred to be saved:touch .gitignore # create a .gitignore fileecho \"file_name\" &gt;&gt; .gitignore # add the file name to the .gitignore fileecho \"*.log\" &gt;&gt; .gitignore # ignore all the files with .log extensionBranchingBranching is one of the most useful features of git. It allows you to create a new branch based on the current working state of the repository. And you can make changes to the new branch without affecting the current branch. Once you are happy with the changes, you can choose to merge the new branch to the current branch, or graft features in different commits. My favorite way to think about what does branching doCreate a branchgit branch &lt;branch_name&gt; # create a new branchgit checkout &lt;branch_name&gt; # switch to the new branchgit checkout -b &lt;branch_name&gt; # create a new branch and switch to itgit branch -d &lt;branch_name&gt; # delete the branchgit branch # check the branch listThere is also a way to create a snapshot of current working state. It is sort of like a branch, but more often it is used for a milestone checkout. It’s called tag. tag branch will not be affected by any commits unless forced being renamed. Create a taggit tag &lt;tag_name&gt; # create a new taggit tag -a &lt;tag_name&gt; -m \"tag message\" # create a new tag with a messagegit tag -d &lt;tag_name&gt; # delete the taggit tag -a -f &lt;tag_name&gt; &lt;commit id&gt; # force rename the tag to a specific commitgit checkout &lt;tag_name&gt; # switch to the taggit tag # check the tag listWhen you want to combine two branches together, you can use merge. Commits from second branch will join merging branch if there is no conflict. Bear in mind, when anything that is not added to staging area and committed, it is in the head state. Anything in the head state will be not be merged to the current branch and stay in the staging area.Merge the branchesgit merge &lt;branch_name&gt; # merge the branch to the current branchgit merge --no-ff &lt;branch_name&gt; # merge the branch to the current branch as a new commitgit merge --squash &lt;branch_name&gt; # merge the branch to the current branch as a new commit with all the changes in one commit, note the changes will be in the staging areaAnother way to combine the branches is to use rebase. Rebasing allows a linear log history. It is useful when you want to keep the log history clean and easy to read.Rebase the branchesgit rebase &lt;branch_name&gt; # rebase the current branch to the branchgit rebase -i &lt;branch_name&gt; # rebase the current branch to the branch with interactive modeConfigurationsWe don’t need to configure anything to use git, but it is recommended to do so if you are collaborating with others visa online hosting services like github. Configure the user name and emailgit config --global user.name \"user name\" # configure the user namegit config --global user.email \"user email@domain.com\" # configure the user emailgit config --global color.ui auto # configure the coloring in command linegit config --global --list # check the global configurationsAnother thing we can do is to set aliases for the commands in git, just to make our life easier. Set aliases for the commandsgit config --global alias.&lt;alias_name&gt; &lt;command&gt; # set alias for the command#common aliasesgit config --global alias.st status # set alias for statusgit config --global alias.ci commit # set alias for commitgit config --global alias.br branch # set alias for branchgit config --global alias.co checkout # set alias for checkoutgit config --global alias.unstage 'reset HEAD --' # set alias for unstagegit config --global alias.lg \"log --oneline --decorate --all --graph\" # set alias for logRemote RepositoryRemote repository is a repository that is hosted online used for saving local repos or collaboration with other users. A remote repository should first be created online first. For example in github, you can go to your main page and click the + button on the top right corner and select New repository. Then you can follow the instructions to create a new repository. Or you can create a online repo by forking an existing repo, which will make a copy of the existing repo to your account. With an repo in your hosting service, you can then clone the repo to your local machine by HTTPS or SSH. Different hosting services may have different way to config HTTPS authentication, in github, HTTPS connections does not support using account and password in terminal anymore from August 2021, you will have to setup a Personal Access Token (PAT) to authenticate. Following will show a more secure protocol by using SSH. Generate SSH keyssh-keygen -t ed25519 -C user.email@domain.com # generate a new ssh keyNote that -t ed25519 is the encryption algorithm, Some people also use older algorithms such as rsa. -C is the comment for the email address you used in github. $ Generating public/private ed25519 key pair.$ Enter file in which to save the key (C:\\Users\\simon/.ssh/id_ed25519): You can press enter to use the default location.$ Created directory 'C:\\\\Users\\\\xxx/.ssh'.$ Enter passphrase (empty for no passphrase):You can also optionally set a passphrase for the key if you are extremely cautious, otherwise press enter. Add the public key on GithubOnce generated, the terminal should tell you where the key is saved, usually it is in ~/.ssh. In ~/.ssh folder, you should see two files, id_ed25519 and id_ed25519.pub. The first one is the private key, and the second one is the public key. You should never share your private key. And you can upload the public key to github.com/settings/keys by creating New SSH key with all text in id_ed25519.pub.Now, one more step is to add the private key in local SSH agent, windows command prompt does not seem to support eval, git bash can be used instead. Add the private key in local SSH agenteval $(ssh-agent -s) # start the ssh agentssh-add ~/.ssh/id_ed25519 # add the private keyNow you can clone the repo by SSH. Clone the repo by SSHgit clone SSH_URL # clone the repo by SSH$ Cloning into 'repo_name'...$ This key is not known by any other names.$ Are you sure you want to continue connecting (yes/no/[fingerprint])? #Type yesOnce remote repository is cloned in local machine, there are several ways to communicate with the remote repo once there are new commits in the local. Exchange commitsgit push origin &lt;branch_name&gt; # push the commits to the remote repogit push #if cloned branch, git will default to push to origin, which is short for remote repogit pull # pull the commits from the remote repogit fetch origin &lt;branch&gt; # fetch  particular branch from remote repogit fetch # fetch all branches from remote repoVscode TutorialSince VScode is the best editor on earth, hands down. It of course integrate git functionalities. Check the detailed official tutorial series from VScode for git. (TBC)"
  },
  
  {
    "title": "Smoothed Particle Hydrodynamics",
    "url": "/posts/smoothed_particle_hydrodynamics/",
    "categories": "Numerical Methods",
    "tags": "SPH, Fluid Dynamics, Simulation, Computer Graphics",
    "date": "2023-02-12 15:00:00 +0100",
    





    
    "snippet": "  “No matter how hard you squeeze your fist, there always is a gap in the atomistic scope.”I was so fascinated by this phenomenon when a physics teacher told us about intermolecular forces in middl...",
    "content": "  “No matter how hard you squeeze your fist, there always is a gap in the atomistic scope.”I was so fascinated by this phenomenon when a physics teacher told us about intermolecular forces in middle school, that is, particles of matters attract each other within a certain range and push each other away when they are too close. This simple idea has helped me to conceptualise how Smoothed Particle Hydrodynamics(SPH) works. Particles will act and react to its surrounding particles, the closer they are, bigger the influence.SPH is a numerical discretisation method, and should not be confused as one of Computational Fluids Dynamics(CFD) methods. It is true that SPH has many applications in fluids simulation and widely used in computer graphics community. And it can be derived to many forms to solve partial differential equations such as the Euler equation(inviscid fluids) and Navier-Stoke equation in a lagrangian system. However, it was originally designed for astrophysical simulation, and later served as an approximation method in continuum mechanics. More importantly, SPH has strong theory supports, researchers have been working for decades to provide mathematical soundness and robustness of SPH. In this post, I will introduce the basic math of SPH and how it works.Fluid simulation using SPH[2]Meaning of SPHThe “Smoothed Particle Hydrodynamics” method  consists of 3 terms that reveal the quintessence of its ideology and functionality. The ‘SMOOTHED’ term indicates the method uses a smooth kernel function to approximate a point of interest using its local neighbouring particles with different weights. ‘Particle’ specifies it is a Lagrangian mesh-free particle method. ‘Hydrodynamics’ means this method is designated for applications in continuum mechanics problems.Function ApproximationThe properties of a continuous field such as density, velocity, and pressure can be expressed as a set of PDEs. To solve the PDEs, we need to find the integral representation of the continuous function. We can estimate a function’s integral in an infinitesimal range by calculating the area beneath the curve. The mean value theorem equips us with a nice integral representation so the integral value at any point can be calculated.Mean Value Theorem for Integral Representation\\[\\begin{aligned}f(X) &amp;= f(X)\\cdot 1 \\\\ &amp;= f(X) \\int \\lim_{\\epsilon \\to 0} \\frac{1}{2\\epsilon}(u(X')_{x'- \\epsilon } - u(X')_{x'+\\epsilon})dX' \\\\ &amp;= f(X) \\int \\delta(X-X')dX' \\\\&amp;= \\int f(X') \\delta(X-X')dX'\\\\\\end{aligned}\\]where the $\\delta(X-X’)$ is the well known Dirac-Delta function, The delta function has to meet the condition that $\\int \\delta\\left(X -X’\\right)dX’ = 1$ for the equation to be an exact solution, it is also know as the normalisation(unity) condition. There are a few more important conditions the smoothing function has to meet will be discussed later.In SPH, the Dirac-Delta function is replaced by a smooth function so an approximation model can be computed. The smooth function with finite support to approximate the function can be written as follows:\\[&lt;f(X)&gt;=\\int_{\\Omega} f\\left(X^{\\prime}\\right) W\\left(X-X^{\\prime}, h\\right) d X^{\\prime}\\]where $&lt;f(X)&gt;$ is the approximate value of the function at the position X, $&lt;f(X)&gt;$ is often written in $f(X)$ for simplicity,  $f(X^{\\prime})$ is the value of the function in the position of the neighbouring points. $W\\left(X_{i}-X_{j}, h\\right)$ is the kernel weights evaluated at the position $X^{\\prime}$ based on the distance between $X$ and $X^{\\prime}$. The conditions for construction of kernel function are introduced in later section.A vectorial function f has spatial derivative of $\\nabla f$. Then the arbitrary function can be written as in the form of SPH approximation:\\[\\nabla f(X)=\\int_{\\Omega}\\left[\\nabla f\\left(X^{\\prime}\\right)\\right] W\\left(X-X^{\\prime}, h\\right) d X^{\\prime}\\]The differential operations are linear operators, thus it obeys following product rule:\\[\\nabla (\\varphi f)=\\varphi \\cdot (\\nabla  f) + (\\nabla \\varphi) \\cdot f\\]Therefore, the term at the right side of the derivative equation can be written as:\\[\\nabla f\\left(X^{\\prime}\\right) W\\left(X-X^{\\prime}, h\\right)=\\nabla  f\\left(X^{\\prime}\\right) \\cdot W\\left(X-X^{\\prime}, h\\right) -f\\left(X^{\\prime}\\right) \\cdot \\nabla W\\left(X-X^{\\prime}, h\\right)\\]Split the integration part of the derivative Equation, we get:\\[\\nabla f(X)=\\int_{\\Omega} \\nabla f\\left(X^{\\prime}\\right) \\cdot W\\left(X-X^{\\prime}, h\\right) d X^{\\prime}-\\int_{\\Omega} f\\left(X^{\\prime}\\right) \\cdot \\nabla W\\left(X-X^{\\prime}, h\\right) d X^{\\prime}\\]Applying the divergence theorem, we get an equivalent equation as:\\[\\nabla f(X)=\\int_{s} f\\left(X^{\\prime}\\right) W\\left(X-X^{\\prime}, h\\right) \\mathbf{n} \\cdot d \\mathbf{S}-\\int_{\\Omega} f\\left(X^{\\prime}\\right) \\cdot \\nabla  W\\left(X-X^{\\prime}, h\\right) d X^{\\prime}\\]Since the kernel function is compactly supported, the local domain surface integral is assumed to be zero, thus the derivative equation can be express in the term of function value and derivative of the smooth function only:\\[\\nabla f(X)=-\\int_{\\Omega} f\\left(X^{\\prime}\\right)  \\nabla W\\left(X-X^{\\prime}, h\\right) d X^{\\prime}\\]Similarly, we can obtain the divergence approximation by:\\[\\nabla \\cdot f(X)=-\\int_{\\Omega} f\\left(X^{\\prime}\\right) \\cdot \\nabla  W\\left(X-X^{\\prime}, h\\right) d X^{\\prime}\\]The Laplacian of a function is defined as a second-order differential operation. It is defined as the divergence of the gradient of the function:\\[\\Delta f=\\nabla^{2} f=\\nabla \\cdot \\nabla f\\]Thus, using the same technique we can obtain the Laplacian approximation as:\\[\\Delta f(X)=-\\int_{\\Omega} f\\left(X^{\\prime}\\right) \\cdot \\Delta W\\left(X-X^{\\prime}, h\\right) d X^{\\prime}\\]Generally, higher-order derivatives can be repeatedly derived using mathematical derivations from their previous order equations recursively. A first-order accuracy is proven when more properties of the smoothing function are introduced.Function DiscretisationA continuous form of functions and their derivatives are phrased in integral representations. For computers to solve the numerical scheme, accurate discretisations are required. In SPH, the discretisation method is also called particle approximation. The computational domain is a collection of discrete particles with physical properties, and each particle is evaluated and summed by neighbouring particles. Since the Dirac-Delta function would model an idealised point mass with no spatial extents, thus the mass can not be computed as the spatial integral from density. The infinitesimal spatial extents $dX^{\\prime}$ will have to be replaced by a $\\Delta V$. Hence the mass can be modelled as:\\[m = \\int \\rho(X)dV\\]Therefore, the discretisation of the kernel approximation are procured from integration form of SPH approximation:\\[\\begin{aligned}f(X) &amp;= \\int_{\\Omega} f\\left(X^{\\prime}\\right) W\\left(X-X^{\\prime}, h\\right) d X^{\\prime} \\\\&amp; \\approx \\sum_{j=1}^{n} f(X_{j})   W\\left(X-X_{j}, h\\right) \\Delta V_{j}\\\\&amp; = \\sum_{j=1}^{n} f(X_{j})    W\\left(X-X_{j}, h\\right) \\frac{m_{j}}{\\rho_{j}} \\\\&amp; =  \\sum_{j=1}^{n} \\frac{m_{j}}{\\rho_{j}}  f(X_{j})   W\\left(X-X_{j}, h\\right)  \\\\\\end{aligned}\\]In a similar fashion, the continuous derivatives equations can be written as:\\[Gradient: \\nabla f(X) =  \\sum_{j=1}^{n} \\frac{m_{j}}{\\rho_{j}}  f(X_{j})  \\nabla  W\\left(X-X_{j}, h\\right)\\]\\[Divergence: \\nabla \\cdot f(X) =  \\sum_{j=1}^{n} \\frac{m_{j}}{\\rho_{j}}  f(X_{j}) \\cdot \\nabla  W\\left(X-X_{j}, h\\right)\\]\\[Laplacian: \\Delta f(X) =  \\sum_{j=1}^{n} \\frac{m_{j}}{\\rho_{j}}  f(X_{j})  \\Delta  W\\left(X-X_{j}, h\\right)\\]where $ \\nabla  W\\left(X-X_{j}, h\\right)$ is often simplified as $ \\nabla  W_{ij}$ and  $\\nabla W_{ij} = \\frac{X_i - X_j}{r_{ij}}\\frac{\\partial W_{ij}}{r_{ij}} =  \\frac{X_{ij}}{r_{ij}}\\frac{\\partial W_{ij}}{r_{ij}}$, $r_{ij}$ is the scalar distance between two points.And above equations are the basis of SPH numerical scheme, we have all these discretisation tools to solve a partial differential equation.Smoothing functions conditionsSmoothing functions is sometimes named kernels in approximation theory. The smoothing functions should be at least twice continuous differentiable due to the formulation in SPH. Going back to the integral representation of the SPH formulation, the errors can be analysed by Taylor series expansion:\\[\\begin{split}f(X) &amp;= \\int f\\left(X^{\\prime}\\right) W\\left(X-X^{\\prime}, h\\right) d X^{\\prime} \\\\&amp;= \\int [f(X) + \\nabla f(X - X^{\\prime}) + \\frac{1}{2}(X - X^{\\prime}) \\cdot \\nabla^{2}f(X - X^{\\prime}) +  O((X - X^{\\prime})^{3})] W\\left(X-X^{\\prime}, h\\right) d X^{\\prime} \\\\&amp;= f(X) \\int W\\left(X-X^{\\prime}, h\\right) dX^{\\prime} + \\nabla f(X) \\int (X-X^{\\prime}) W\\left(X-X^{\\prime}, h\\right) dX^{\\prime} +  O((X - X^{\\prime})^{2})\\\\\\end{split}\\]The normalisation/unity condition for smooth functions is inherited from the Dirac-Delta function, which makes the integral in the first term of the above equation conveniently become 1. To make the approximation $1^{st}$ order accurate, a symmetric property can be introduced to smooth functions, so that the integral in the second term in the taylor series will be cancelled out to zero. Other properties are summarised as follows:Normalisation/Unity: $\\int W(X-X^{\\prime}) dX^{\\prime} = 1$. This is one of the most important requirements for smoothing functions so that the integral of the kernel in the local domain is normalised.Symmetric: $W(X-X^{\\prime}) = W(X^{\\prime} - X)$. As proven previously in the Taylor expansion analysis, the Symmetric property is necessitated to ensure $1^{st}$ order accuracy.Compact support: $W(X-X^{\\prime}) = 0$, if $ \\left\\lvert X-X^{\\prime} \\right\\rvert&gt; kh $, where h is the support radius length and k is an arbitrary scaling factor. In SPH approximation, compact support allows the kernels only convolve only the support domain and eliminate the influence of discrete particles from far in the global domain, which guarantees the local accuracy for sparse particle modelling. Compactness also provides the SPH adaptability to neighbourhood search algorithms for efficient computing.Delta function property: $\\lim _{h \\rightarrow 0} W (X-X^{\\prime}, h )=\\delta (X-X^{\\prime})$. As the support radius tend to zero, the discrete approximation should be equal to the continuous integral representation.Positivity:$W(X-X^{\\prime}) \\ge 0$. Positiveness ensures that the physical properties of particles remain meaningful, such as the density should always keep positive for a stable simulation.Decay: The weights computed by the smoothing function should monotonically decrease due to the consideration that further particles should have less physical effects on centre points.Smoothness:: The smoothing functions needs to be sufficiently smooth until the second order for an accurate approximation for gradient and Laplacian terms. The smoothness and continuousness in the derivatives greatly impact numerical results and their stability.Gaussian kernel with cutting off conditionAn obvious selection of kernels would be using the normalised Gaussian function:\\[W\\left(X_{i}-X_{j}, h\\right) = W(R, h)=\\alpha_{d} e^{-R^{2}}\\]The Gaussian kernel is twice continuously differentiable and has a sufficient enough smoothness for second-order derivatives. Though it is really not compactly supported since as the further distance, the weights will approach zero but never reach zero.Benchmark ResultA quick demo of approximate a simple 2d function and its gradient and laplacian is demonstrated below, 900 data points are used, some randomness of the collation points are also added.the test function used is:\\[f(x, y) = -(cos^2(x) + cos^2(y))^2\\]            Analytical      Approximation                              Gradient                        Magnitude of Gradient                        Laplacian                        Recommended literatureMy favorite piece of introduction to SPH is the Eurographics tutorial by Bender and Koschier, which is a very good starting point for beginners. They are the authors of the open source SPH library SPlisHSPlasH. This review by Lind is a very well written and comprehensive introduction to SPH flow modeling, which is a good reference for further reading. Introduction from the father of SPH Monaghan and slightly more advanced introduction from Price are also very nice reads.fro fluid simulation, the recommended sequence is: WCSPH -&gt; PCISPH -&gt; IISPH -&gt; DFSPHBooks I like:  &lt;Smoothed Particle Hydrodynamics - Fundamentals and Basic Applications in Continuum Mechanics&gt;, Carlos Alberto Dutra Fraga Filho  &lt;Smoothed Particle Hydrodynamics: A Meshfree Particle Method&gt;,  G. R. LiuReference[1] Farmelo, The Strangest Man: The Hidden Life of Paul Dirac, Quantum Genius, 2009. [2] An open source software provide simulations based on SPH, SPlisHSPlasH."
  },
  
  {
    "title": "How to make a free website like this",
    "url": "/posts/how_to_make_web_like_this/",
    "categories": "Web Development",
    "tags": "HTML, CSS, Markdown, jekyll, Web design",
    "date": "2023-02-08 21:50:00 +0100",
    





    
    "snippet": "Jon Barron’s template has become sort of gold standard portfolio for computer vision researcher’s. Recently I decided to upgrade it to this site for more functionalities and of course a bit of fanc...",
    "content": "Jon Barron’s template has become sort of gold standard portfolio for computer vision researcher’s. Recently I decided to upgrade it to this site for more functionalities and of course a bit of fanciness.Without any great knowledge about website design, I took the first step searching for some Github Page template since Github provides free host to static websites. Not only I found it’s super-duper easy to do this web, but also it came to me as a treasure box with thousands of freely available gem themes. (Interestingly, jekyll is managed by RubyGems). Hence it is only right for me to share another tutorial as an amateur.Other great TutorialsThe Chirpy theme live demo gives a detailed tutorial on creating this website and posts. Another in-depth tutorial for Windows users is provided by Jade. Linux users can watch the video from Techno Tim:TL;DR versionIf you feel lazy and want to get the web done in 1 hour, just follow my too-long-didn’t-read version below.Prerequisite knowledge  Git(not much)  Markdown(very easy)Prerequisite installations  Github account  Windows:            Install Git, just keep the default installation settings.      Install Ruby+Devkit latest stable release in bold text.      Open a command prompt or PowerShell from Windows search bar.      Install Jekyll        gem install jekyll                    Install bundle        gem install bundle                      Linux:            Install Git        sudo apt install git-all                    Install Ruby        sudo apt-get install ruby-full build-essential zlib1g-dev                    Add environment variables        echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.bashrcecho 'export GEM_HOME=\"$HOME/gems\"' &gt;&gt; ~/.bashrcecho 'export PATH=\"$HOME/gems/bin:$PATH\"' &gt;&gt; ~/.bashrcsource ~/.bashrc                    Install jekyll and Bundler        gem install jekyll bundler                    If installed successfully, type following commands either in Windows or Linux shell should show the version of the packages:ruby -vgem -vjekyll -vbundler -vBuild the websiteNow all the required softwares should have been installed, following actions will make the minimal Chirpy theme to work. Of course there are thousands other themes are available, the process is more or less the same.1. Fork the Chirpy starterMake sure you fork the Chirpy starter, not the the Chirpy demo repo.name the forked repo as GITHUB-USERNAME.github.io. In my case, it is simonzeng7108.github.io.2. Clone the repo to local pcYou should clone the Github repo to your local folder either by download the repo or:git clone https://github.com/GITHUB-USERNAME/GITHUB-USERNAME.github.io.git3. Customise the _config.yml_config.yml is the main file contains the info about you such as the website title, bio, your social links and etc…4. Build the website locallyOpen Windows or Linux shell and cd to local repo, then typebundlebundle exec jekyll sNow you can check your website at http://127.0.0.1:4000/.5. Push to GithubFor Windows users, one last step before pushing to Github repo, since Github cloud serve is linux based.bundle lock --add-platform x86_64-linuxThen for all users, just do the regular git push commands.git add .git commit -m \"Init\"git pushAfter successfully pushing the local repo to Github, the Github will take a few minutes to build over the cloud, you can see the process at your repo’s Actions tab, green means build finished.6. Check your websiteTa-da, your free website is available at https://GITHUB-USERNAME.github.io. For more customisation or create posts, check Chirpy official tutorialCommon issuesLocal build fail after run `bundle exec jekyll s`Make sure the 4 prerequisite packages are installed correctly by checking the software versions. My experience was Ruby version 2+ does not work very well and should be updated version 3+.Posts are generated locally, but not on Github domainFor some reason, Github may not recognise some changes, just go to your Github repo's 'Actions' tab, click 'Build and deploy' and click 'Run workflow' to manually run the Github build again."
  },
  
  {
    "title": "Preface",
    "url": "/posts/preface/",
    "categories": "MISC",
    "tags": "Preface, Blogging, Demo, Template",
    "date": "2023-02-05 21:00:00 +0100",
    





    
    "snippet": "Harbour side walkToday, half way finishing this first ever post in my blog, we went for a harbour side walk with our new friend Gabriele, a visiting PhD student from Italy. The harbour side walk se...",
    "content": "Harbour side walkToday, half way finishing this first ever post in my blog, we went for a harbour side walk with our new friend Gabriele, a visiting PhD student from Italy. The harbour side walk seems to become a pilgrimage for new comers to Bristol, except we don’t worship along the way. It usually starts from our office and comes back ending in a pub. The weather is beautifully rare in February time in the UK. We had fun.A jogger on the Leigh wood walkBristol Marina, not far from Banksy’s Girl with the Pierced EardrumUnder the Brunel way flyoverPurpose of this blogThis blog is not a place for me to write long and stinky diaries. I want to make it as an organised and clean space to store my knowledge along my PhD. I want to share this scientific knowledge with concise English and a bit of computer code to you. It is also the best way to test and practice what I have learnt. Let’s finish this post with a Feynman’s quote:  “What I Cannot Create, I Do Not Understand.”"
  }
  
]

